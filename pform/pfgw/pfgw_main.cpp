#if defined(_MSC_VER) && defined(_DEBUG)
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
#endif

#include "primeformpch.h"
#include <signal.h>
#include "../../pform/pfio/pfini.h"
#include "pfgw_version.h"
#include "pfgw_globals.h"
#include "../../pform/pfgwlib/asmimp.h"
#ifdef _MSC_VER
#include "cpuid.h"
#else
#include "../../packages/gwnum/cpuid.h"
#include <sys/resource.h>
#endif

// Variables which allow "forced" stoppage.  Allows ^C to have more control in the console app, and allow
// the WinPFGW to start-stop-continue the process.  Used int the gwPRP() function and within the
// CallFunction() function of PFIterativeSymbol class.  This catches PRP's Prime test, and factoring.
// After each iterative computation, the g_bExitNow variable is checked, and if it "turns" true, then
// the loop exits.
bool volatile g_bExitNow;
bool volatile g_bExited;
uint64 g_u64ResidueVal;

Integer *ex_evaluate(PFSymbolTable *pContext,const PFString &e,int m);

int g_PRP_ReturnCode;
int g_PFGW_Mod_Checking;

#ifndef GW_UNDERSCORE
#define Imodtest _Imodtest
#endif

static bool s_bCommandLineParse=false;
extern "C"
{
void Imodtest(DWORD x,DWORD y,DWORD *p1, DWORD *p2);
};

PFSimpleFile *pFile=NULL;
PFIni *g_pIni;
int g_nIterationCnt=2500;
int g_CompositeAthenticationLevel = 0;   // valid values are 0, 1, 2, 3, 4, 5
int g_ExtraSQFree = 100;
int g_Cert_Type = -1;
int g_Cert_Delete = -1;
bool g_QuickMode = false;
bool g_bVerbose = false;
bool g_bWinPFGW_Verbose = false;
bool g_bTestingMode = false;
bool g_bForceRoundOffChecking = false;
bool g_FFTSizeOnly = false;
char g_ModularSieveString[256];
char g_szInputFileName[1024];
int iBase=3;
int iBaseUsed=3;
bool g_bGMPMode=false;
unsigned long clocks_per_sec;         // Machine dependent

// these are used by SCRIPTFile's since they do not have access to the "global"
extern uint64 g_MinStartingPrimeToFactor, g_MaxStoppingPrimeToFactor;

extern bool g_bHideNoFactor;          // in f_factor.cpp
extern bool g_bReLoadFactorFile;      // in f_factor.cpp

bool g_bTrialFactor=true;

// These are globals which can only be set by WinPFGW.  They come in the "undocumented" switch -$ which only
// WinPFGW and the command line parser "know" about.  That switch is NOT in the help, and for command line
// usage, does not have any usable stuff.
#ifdef _MSC_VER
HWND g_hWnd_Dialog=0;
#endif

/* signal functions   Since pfgw is closed using ^c, the destructor to the pFile was not
   being called (and the ini file not being flushed).  This function will be called, and will
   flush the ini file correctly.
*/
static bool bAtExitRegistered = false;    // for the atexit registration, make sure it is only done one time */
// SIGINT not supported under Win32 :(  (VC build at least)
extern "C" void ctrl_c_func(int)
{
   PFPrintfStderr ("\nCtrl-C detected, shutting down the program.\n");
   delete pFile;
   pFile = 0;
   exit(2);
}


// Note that NONE of these are caught by VC with signals.  They are caught by try{} catch(...){}  HOWEVER VC has bugs in the
// fact that NO destructors are called when these are caught as exeptions!!! This can cause serious memory/resource leaks if
// not coded for that.  These are for Unix's which may not handle these types of exceptions in a try catch.  Now they will.
// NOTE there may be other exceptions which also need to be added (SIGEMT??)
extern "C" void CatcherThrower_SIGABRT(int)
{
  signal(SIGABRT, CatcherThrower_SIGABRT);
  PFPrintfStderr("\nSignal SIGABRT caught\n");
  exit(2);
  //throw "SIGABRT";
}

extern "C" void CatcherThrower_SIGSEGV(int)
{
  signal(SIGSEGV, CatcherThrower_SIGSEGV);
  PFPrintfStderr("\nrSignal SIGSEGV caught\n");
  exit(2);
//  throw "SIGSEGV";
}

extern "C" void CatcherThrower_SIGILL(int)
{
  signal(SIGSEGV, CatcherThrower_SIGILL);
  PFPrintfStderr("\nSignal SIGILL caught\n");
  exit(2);
//  throw "SIGILL";
}

#ifdef _MSC_VER
// This seems to be the only way which ^C is "caught" in Win32 programs (at least for VC that is.  Win95/NT don't handle SIGINT)
BOOL WINAPI HandlerRoutine(DWORD /*dwCtrlType*/)
{
   // Note dwCtrlType can be:
   //CTRL_C_EVENT A CTRL+C signal was received, either from keyboard input or from a signal generated by the GenerateConsoleCtrlEvent function.
   //CTRL_BREAK_EVENT A CTRL+BREAK signal was received, either from keyboard input or from a signal generated by GenerateConsoleCtrlEvent.
   //CTRL_CLOSE_EVENT A signal that the system sends to all processes attached to a console when the user closes the console (either by clicking Close on the console window's window menu, or by clicking the End Task button command from Task Manager).
   //CTRL_LOGOFF_EVENT A signal that the system sends to all console processes when a user is logging off. This signal does not indicate which user is logging off, so no assumptions can be made.
   //CTRL_SHUTDOWN_EVENT A signal that the system sends to all console processes when the system is shutting down. Note that this signal is received only by services. Interactive applications are terminated at logoff, so they are not present when the system sends this signal. Services also have their own notification mechanism for shutdown events. For more information, see Handler.

   PFOutput::EnableOneLineForceScreenOutput();
   PFPrintfStderr ("\n^C Handler Routine called, shutting down program\n");
   g_bExitNow = true;
   if (!s_bCommandLineParse)
      ExitProcess(2);

   int Cnt = 0;
   while (!g_bExited && Cnt < 50)   // wait at most 5 seconds to shut down
   {
      Sleep(100);
   }
   if (!g_bExited)
   {
      // ususally, the program will exit on it's own (gracefully), so this code will NOT be called.
      delete pFile;
      pFile = 0;
      PFOutput::EnableOneLineForceScreenOutput();
      PFPrintfStderr ("Force Exiting the program.  The thread did not gracefully exit!\n");
   }
   ExitProcess(2);
}
#endif

// Parsing command-line arguments was a little arbitrary. The idea now is to change this
// mechanism. There are three kinds of command-line argument.
// Boolean - symbol set to integer(1) if present
// String  - symbol set to string(v) if present
// Integer - symbol set to atoi(v) if present.

// parameters are denoted by 'A' through 'Z', plus one additional one "_MAIN" (a string)
enum CLOption
{
   cl_illegal,
   cl_boolean,
   cl_long,
   cl_integer,
   cl_string
};

struct CLOptionElement
{
   enum CLOption type;
   int  required;
   LPCTSTR sSymbol;
};

CLOptionElement clList[]=
{
   {cl_integer,   true,    "_ATHENTICATION"},   // a
   {cl_long,      true,    "_BASE"},            // b
   {cl_string,    false,   "_CERTIFICATE"},     // c
   {cl_boolean,   false,   "_DEEPFACTOR"},      // d
   {cl_long,      true,    "_PMAX"},            // e
   {cl_string,    false,   "_FACTORIZE_STR"},   // f
   {cl_string,    false,   "_FERMFACTOR"},      // g (Also -gap= gapper code, and now -gx for extended GF divisiblity)
   {cl_string,    true,    "_HELPER"},          // h
   {cl_boolean,   false,   "_INFO"},            // i lists info such as GMP.dll, and CPU information (from Woltman v22 code)
   {cl_string,    true,    "_JBC"},             // j (Base 2 Phi test code, remove when done, well, maybe it stays as a Mersenne override)
   {cl_boolean,   false,   "_TERSE_OUTPUT"},    // k
   {cl_string,    false,   "_LOGFILE"},         // l
   {cl_boolean,   false,   "_BENCH"},           // m
   {cl_illegal,   false,   ""},                 // n
   {cl_string,    false,   "_ONLYFACTORS"},     // o
   {cl_illegal,   false,   ""},                 // p
   {cl_string,    true,    "_QUIKEXPR"},        // q
   {cl_boolean,   false,   "_ROUNDOFFCHK"},     // r
   {cl_long,      false,   "_PMIN"},            // s
   {cl_string,    false,   "_TESTMODE"},        // t
   {cl_long,      true,    "_UPDATEINTERVAL"},  // u partial screen update. Set the interval (or turn it off with 0)
   {cl_boolean,   false,   "_VECTORMODE"},      // v
   {cl_illegal,   false,   ""},                 // w
   {cl_long,      false,   "_EXTRA_SQFREE"},    // x
   {cl_illegal,   false,   ""},                 // y
   {cl_illegal,   false,   ""},                 // z
   {cl_illegal,   false,   ""},                 // A
   {cl_illegal,   false,   ""},                 // B
   {cl_illegal,   false,   ""},                 // C
   {cl_illegal,   false,   ""},                 // D
   {cl_illegal,   false,   ""},                 // E
   {cl_boolean,   false,   "_FFT_SIZE_ONLY"},   // F
   {cl_illegal,   false,   ""},                 // G
   {cl_illegal,   false,   ""},                 // H
   {cl_illegal,   false,   ""},                 // I
   {cl_illegal,   false,   ""},                 // J
   {cl_illegal,   false,   ""},                 // K
   {cl_illegal,   false,   ""},                 // L
   {cl_illegal,   false,   ""},                 // M
   {cl_boolean,   false,   "_NORMAL_PRIORITY"}, // N
   {cl_illegal,   false,   ""},                 // O
   {cl_illegal,   false,   ""},                 // P
   {cl_illegal,   false,   ""},                 // Q
   {cl_illegal,   false,   ""},                 // R
   {cl_illegal,   false,   ""},                 // S
   {cl_illegal,   false,   ""},                 // T
   {cl_illegal,   false,   ""},                 // U
   {cl_boolean,   false,   "_VERBOSE"},         // V
   {cl_illegal,   false,   ""},                 // W
   {cl_illegal,   false,   ""},                 // X
   {cl_illegal,   false,   ""},                 // Y
   {cl_illegal,   false,   ""}                  // Z
};

static bool bIsWinPFGW = false;

void Usage()
{
// All of this help text has been "formatted" to a 80x25 screen size.
LPCTSTR Help_Text1 = "\
\n\
--===COPYRIGHT AND LICENSE===--\n\
\n\
PrimeForm/GW - a program to perform a variety of primality tests.\n\
Copyright (C) 1999-2009, The OpenPFGW project at sourceforge.\n\
\n\
See the accompanying LICENSE.pfgw for the Terms and Conditions\n\
regarding the use of this product and third-party libraries therein.\n\
\n\
This product uses the gwnum libraries (version 25) by George Woltman.\n\
Copyright 1995-2009 Mersenne Research, Inc., all rights reserved.\n\
See the accomanying LICENSE file, (also see http://www.mersenne.org/prize.htm)\n\
\n\
This product uses the GNU Multiple Precision Library (version 4.1.3).\n\
Copyright (C) 1991-2009 Free Software Foundation, Inc.\n\
See the accompanying COPYING.LIB for Terms and Conditions.\n\
\n\
";
LPCTSTR Help_Text2 = "\
--===BASIC USAGE===--\n\
\n\
pfgw supports a variety of command-line options. The simplest is\n\
\n\
pfgw filename\n\
\n\
which proceeds directly to a probable primality test of every number in the\n\
specified file, one expression per line.\n\
\n\
--===OPTIONS===--\n\
\n\
In addition, the following command-line flags are supported. Flags may appear\n\
in any order on the command-line, and are prefixed by a '-' sign.\n\
\n\
-q<expression> enter the \"q\"uick expression to be tested.\n\
\n\
--  Use a double dash to have PFGW query you for an expression to test Any\n\
file name entered will be ignored when using either the -- or -q options\n\
\n\
-l<logfilename> will output all text not only to the screen, but also to \n\
the logfilename file (if <logfilename> is blank, then pfgw.out is used\n\
\n";
//test.  (-d is also used to \"deep\" test NewPGen multi-prime searches)\n";
LPCTSTR Help_Text3 = "\
--===MORE OPTIONS===--\n\
\n\
-? This help message.\n\
\n\
-f<percent> trial-factors every number before attempting any primality test. If\n\
a factor is found, the PRP test is not performed. Optional <percent> is the\n\
percent of what pfgw \"normally\" trial factors to.  i.e. default is -f100.\n\
The <percent> can be from 1 up to 65535.  <percent> ignored if -e switch used.\n\
\n\
-d will perform deep factoring, when used along with -f. In -f mode, if a\n\
factor is found, processing of that number stops. The -d flag continues to\n\
find factors until the trial-factoring limit, or until the number is\n\
completely factored. If a cofactor exists, it is passed to the primality\n\
test.\n\
\n\
-s<number>\n\
-e<number>\n\
Used in conjunction with the -f and -v flags, the minimum and maximum\n\
values for trial-factoring can be set. The defaults are -s0, and -e\n\
determined by an internal algorithm.\n\
\n\
-k produces terse output\n\
\n\
-o (or -od) factor [O]nly mode. In this mode instead of performing a primality\n\
test, the expression or factors are written to stdout.  If the switch -od is\n\
used, then the decimal expansion of the number is output.\n\
";
LPCTSTR Help_Text4 = "\
--===MORE OPTIONS===--\n\
\n\
-b<number> allows you to override the PRP testing base, which defaults\n\
to 3. Legal bases are in the range 2 to 255.\n\
\n\
-n  Nice mode (reduce PC's priority to idle, Win32 only)\n\
\n\
-v will process the numbers in the input file in modular vector form.\n\
For each prime in a factor range set by the -s and -e flags, the value\n\
of each number modulo that prime is output to stdout.\n\
\n\
-g<o> Test for factors of GFN's. If -go then ONLY test for factors (no PRP).\n\
-gx<o> Test for factors of \"extended\" GFN's. xGFN's form is a^2^n+b^2^n\n\
\n";
LPCTSTR Help_Text5 = "\
--===ADVANCED OPTIONS FOR DETERMINSTIC TESTS===--\n\
\n\
-t currently performs a deterministic test. By default this is an N-1\n\
test, but N+1 testing may be selected with '-tp'. N-1 or N+1 is\n\
factored, and Pocklington's or Morrison's Theorem is applied. If 33%%\n\
size of N prime factors are available, the Brillhart-Lehmer-Selfridge\n\
test is applied for conclusive proof of primality. If less than 33%%\n\
is factored, this test provides 'F-strong' probable primality with\n\
respect to the factored part F.\n\
\n\
-tc performs a combined N-1 and N+1 test. Both tests are executed to\n\
get strong probable primality to two factored parts F and G.\n\
If F<G and F.G^3>N, the N+1 variant of BLS can give a proof.\n\
If F>G and F^3.G>N, the N-1 variant of BLS can give a proof.\n\
In either case, results just short of the target may still give a\n\
proof with sufficient loop tests for perfect squares.\n\
\n\
-h<filename> allows you to include known factors of N-1, N, or N+1\n\
from a file. It is your responsibility to ensure this file includes\n\
only prime expressions, one per line, or the results may be incorrect.\n\
This is most often useful to provide known factors discovered using\n\
another program, which will be sufficient to complete a proof.\n\
\n";
LPCTSTR Help_Text6 = "\
--===ADVANCED OPTIONS FOR DETERMINSTIC TESTS===--\n\
\n\
-x<depth> for deterministic tests to prove a number prime, factorization of\n\
33%% of N-1 (or N+1) is required.  Ocasionally, a number will be just short\n\
of this required amount. If you receive a message stating \"Proof incomplete\n\
rerun with -x24000\" then rerun the proof using the -x switch with whatever\n\
number pfgw stated.  PFGW will attempt to perform some square free loops to\n\
attempt to prove the number (even though it is just short of 33%% factorized)\n\
\n\
-r enables round off error checking for all iterations of all tests\n\
\n\
-a<number> Authenticates composites.  Using a -a0 will PRP test using the\n\
\"normal\" FFT sizes.  A switch of -a1 will test using 1 less bit per\n\
FFT limb.  This will take more time but will also eliminate any chance of\n\
rounding errors inherant with FFT multiplies.  The lower 62 bits of the\n\
results of a PRP test will be listed (on composites only).  This allows\n\
checking for math library errors.  If a run on the same numbers using -a0\n\
and a -a1 results in different residues, then there were round off errors.\n\
";

   // Hmm, input and output.  This code should probably NOT happen for a Windows gui app).
   PFOutput::EnableOneLineForceScreenOutput();
   PFPrintfStderr(Help_Text1);
   PFOutput::EnableOneLineForceScreenOutput();
   PFPrintfStderr(" -- Press enter to continue, or ^C to break --");
   fgetc(stdin);
   if (g_bExitNow)
      return;
   PFOutput::EnableOneLineForceScreenOutput();
   PFPrintfStderr(Help_Text2);
   PFPrintfStderr("-- Press enter to continue, or ^C to break --");
   fgetc(stdin);
   if (g_bExitNow)
      return;
   PFPrintfStderr(Help_Text3);
   PFPrintfStderr("-- Press enter to continue, or ^C to break --");
   fgetc(stdin);
   PFPrintfStderr(Help_Text4);
   PFPrintfStderr("-- Press enter to continue, or ^C to break --");
   fgetc(stdin);
   if (g_bExitNow)
      return;
   PFOutput::EnableOneLineForceScreenOutput();
   PFPrintfStderr(Help_Text5);
   PFOutput::EnableOneLineForceScreenOutput();
    PFPrintfStderr("-- Press enter to continue, or ^C to break --");
    fgetc(stdin);
   if (g_bExitNow)
      return;
   PFOutput::EnableOneLineForceScreenOutput();
   PFPrintfStderr(Help_Text6);
   PFOutput::EnableOneLineForceScreenOutput();
    PFPrintfStderr("-- Press enter to continue, or ^C to break --");
   if (bIsWinPFGW == false)
       fgetc(stdin);
}

#if defined (_MSC_VER)
void ParseWinPFGWStuff(const char *Cmd)
{
   bIsWinPFGW = true;
   if (*Cmd++ != '-')
      return;
   if (*Cmd++ != '$')
      return;
   // Ok, now process all "valid" WinPFGW commands
   Cmd+=2;
   while(Cmd && *Cmd)
   {
      if (strncmp(Cmd, "HWND=", 5))
      {
         Cmd += 8;
         // nanana I can use strtol here Chris ;)
         g_hWnd_Dialog = (HWND)strtol(Cmd,0,16);
      }
      else if (strncmp(Cmd, "Verbose=", 8))
      {
         Cmd += 8;
         // nanana I can use atoi here Chris ;)
         g_bWinPFGW_Verbose = !!atoi(Cmd);
      }
      else
      {
         break;
      }
      Cmd = strchr(Cmd, ' ');
      if (Cmd)
         Cmd++;
   }
}
#endif

// command-line argument parser
bool parseCommandLine(PFSymbolTable *pTable,int argc,char **argv)
{
// I can't think of any reason to look at the launch path
//   PFString sCommandLine=argv[0];
   if (argc == 1)
   {
      Usage();
      return false;
   }

   bool bFirst = true;  // make sure we only process the default stuff from the ini file one time.

ProcessAgain:;
   for(int i=1;i<argc;i++)
   {
      PFString s=argv[i];
      if(((LPCTSTR)s)[0]=='-')
      {
         TCHAR c=((LPCTSTR)s)[1];
         TCHAR cParameter=((LPCTSTR)s)[2];
         int iIndex=-1;
         uint64 u64Value;
         int    i32Value;

         if (cParameter == ' ') cParameter = 0;
         if((c>='A')&&(c<='Z')) iIndex=c-'A'+26;
         if((c>='a')&&(c<='z')) iIndex=c-'a';
         if(c == '?')
         {
            Usage();
            return false;
         }
#if defined (_MSC_VER)
         if(c == '$')
         {
            ParseWinPFGWStuff((LPCTSTR)s);
            continue;
         }
#endif
         if (c == '-')
         {
#if defined (_MSC_VER)
             if(_isatty(_fileno(stdin)))
#endif
            {
               // a "--" argument means "read from stdin"
               PFOutput::EnableOneLineForceScreenOutput();
               PFPrintfStderr("Enter expression followed by carriage return:\n");
            }
            char Line[0x40000];   // 256k max digits.
            PFStringFile *fTmp = new PFStringFile;
            pFile = fTmp;
            fgets(Line, sizeof(Line), stdin);
            strtok(Line, "\r\n");
            fTmp->WriteToString(Line);
            continue;
         }

         if (iIndex!=-1)
         {
            switch(clList[iIndex].type)
            {
            case cl_boolean:
               if (cParameter != 0)
               {
                  PFOutput::EnableOneLineForceScreenOutput();
                  PFPrintfStderr("Switch %s does not take any parameters\n", LPCTSTR(s));
                  return false;
               }

               pTable->AddSymbol(new PFIntegerSymbol(clList[iIndex].sSymbol,new Integer(1)));
               break;
            case cl_long:
               if (cParameter == 0 && clList[iIndex].required)
               {
                  PFOutput::EnableOneLineForceScreenOutput();
                  PFPrintfStderr("Switch %s requires a string parameter\n", LPCTSTR(s));
                  return false;
               };

               u64Value = _atou64(s.Mid(2));
               pTable->AddSymbol(new PFIntegerSymbol(clList[iIndex].sSymbol,new Integer(u64Value)));
               break;
            case cl_integer:
               if (cParameter == 0 && clList[iIndex].required)
               {
                  PFOutput::EnableOneLineForceScreenOutput();
                  PFPrintfStderr("Switch %s requires a string parameter\n", LPCTSTR(s));
                  return false;
               };

               i32Value = atoi(s.Mid(2));
               pTable->AddSymbol(new PFIntegerSymbol(clList[iIndex].sSymbol,new Integer(i32Value)));
               break;
            case cl_string:
               if (cParameter == 0 && clList[iIndex].required)
               {
                  PFOutput::EnableOneLineForceScreenOutput();
                  PFPrintfStderr("Switch %s requires a string parameter\n", LPCTSTR(s));
                  return false;
               }

               if (iIndex == 't'-'a' && cParameter != 0)
               {
                  if (cParameter != 'p' && cParameter != 'm' && cParameter != 'c')
                  {
                     PFOutput::EnableOneLineForceScreenOutput();
                     PFPrintfStderr("Switch %s only takes 'p', 'm' or 'c'\n", LPCTSTR(s));
                     return false;
                  }
               }

               if (iIndex == 'h'-'a')
               {
                  if ('H' == ((LPCTSTR)s)[1])
                     g_bReLoadFactorFile=true;
                  // The -h can have multiple instances
                  IPFSymbol *pSymbol = pTable->LookupSymbol(clList[iIndex].sSymbol);
                  PFString sStr = &argv[i][2];
                  if (pSymbol && pSymbol->GetSymbolType()==STRING_SYMBOL_TYPE)
                  {
                     sStr += "\xFF";
                     sStr += pSymbol->GetStringValue();
                  }
                  pTable->AddSymbol(new PFStringSymbol(clList[iIndex].sSymbol,sStr));
               }
               else
                  pTable->AddSymbol(new PFStringSymbol(clList[iIndex].sSymbol,s.Mid(2)));
               break;
            default:
               if (iIndex == 'o'-'a' && cParameter != 'd')
               {
                  PFOutput::EnableOneLineForceScreenOutput();
                  PFPrintfStderr("Switch %s only takes 'd'\n", LPCTSTR(s));
                  return false;
               }
               PFOutput::EnableOneLineForceScreenOutput();
               PFPrintfStderr("Illegal option %s\n",LPCTSTR(s));
               return false;
               break;
            }
         }
         else
         {
            PFOutput::EnableOneLineForceScreenOutput();
            PFPrintfStderr("Illegal option %s\n",LPCTSTR(s));
         }
      }
      else
      {
         PFStringSymbol *ps=new PFStringSymbol("_MAIN",s);
         pTable->AddSymbol(ps);
      }
   }
   if (bFirst && g_pIni)
   {
      bFirst = false;
      PFString sDefaultSettings;
      g_pIni->GetDefaultSettings(&sDefaultSettings);
      if (sDefaultSettings != "")
      {
         char cpTmp[512];
         char *cppTmp[50];  // allow up to 50 parameters
         argv = cppTmp;
         argc = 1;
         strncpy(cpTmp, LPCTSTR(sDefaultSettings), sizeof(cpTmp));
         PFPrintfLog("Processing with \"Default\" stored parameters of: %s\n", cpTmp);
         cpTmp[sizeof(cpTmp)-1] = 0;
         char *cp = strtok(cpTmp, " ");
         while (cp && argc < 50)
         {
            argv[argc++] = cp;
            cp = strtok(0, " ");
         }
         goto ProcessAgain;
      }
   }
   return true;
}

// Cleanup code for GFN division's allocation.
extern void CleanupGFs();

PFSymbolTable *psymRuntime=0;

int pfgw_main(int argc,char *argv[])
{
   IPFSymbol *pTerseOutput;

   pfgw_main_init();

   // Ok register an atexit function (if not already done)  This allows the pFile to be closed correctly
   // and also flushes the ini file.
   if (!bAtExitRegistered)
   {
#ifdef _MSC_VER
      // The only way I can find to handle ^C in all Win32 environments.  SIGINT does not work in NT or 95
      // (but does in 98)
      SetConsoleCtrlHandler(HandlerRoutine, TRUE);
#else
      signal(SIGINT, ctrl_c_func);
      signal(SIGABRT, CatcherThrower_SIGABRT);
      signal(SIGSEGV, CatcherThrower_SIGSEGV);
      signal(SIGSEGV, CatcherThrower_SIGILL);
#endif
      bAtExitRegistered = true;
   }

   if (!parseCommandLine(psymRuntime,argc,argv))
   {
      pfgw_main_cleanup();
      return 4;
   }

   gwinit2(&gwdata, sizeof(gwhandle), (char *) GWNUM_VERSION);

   if (gwdata.GWERROR == GWERROR_VERSION_MISMATCH)
   {
      PFOutput::EnableOneLineForceScreenOutput();
      PFPrintfStderr ("GWNUM version mismatch.  PFGW is not linked with version %s of GWNUM.\n", GWNUM_VERSION);
      g_bExitNow = true;
      return 4;
   }

   if (gwdata.GWERROR == GWERROR_STRUCT_SIZE_MISMATCH)
   {
      PFOutput::EnableOneLineForceScreenOutput();
      PFPrintfStderr ("GWNUM struct size mismatch.  PFGW must be compiled with same switches as GWNUM.\n");
      g_bExitNow = true;
      return 4;
   }

   PFOutput::EnableOneLineForceScreenOutput();
   pTerseOutput = psymRuntime->LookupSymbol("_TERSE_OUTPUT");
   if (!pTerseOutput)
       PFPrintfStderr ("PFGW Version %s [GWNUM %s]\n\n", VERSION_STRING, GWNUM_VERSION);

   // Get the cpu type from the INI file.  I don't know how big of an impact this
   // makes on PFGW, but on PRP.exe changing the CPU type seemed to make significant
   // differences on certain PC's.  There is no "automatic" changing feature yet,
   // you simple have to "know" what the constants are, and then hand patch the .ini entry.
   if (g_pIni)
   {
      PFString s;
      s="Verbose";
      g_pIni->GetIniBool(&g_bVerbose, &s);
      s = "HideNoFactor";
      g_pIni->GetIniBool(&g_bHideNoFactor, &s);
   }

#if !defined (_DEBUG)
   try
#endif
   {

   s_bCommandLineParse=true;

   // for the moment, assume no _MAIN means a hardcoded path
   PFString sFilename="helper.txt";

   IPFSymbol *pSymbol;

   pSymbol=psymRuntime->LookupSymbol("_VERBOSE");

   if (pSymbol)
      g_bVerbose = true;

   pSymbol=psymRuntime->LookupSymbol("_NORMAL_PRIORITY");

   if (!pSymbol)
#ifdef _MSC_VER
   {
      ::SetPriorityClass(::GetCurrentProcess(), IDLE_PRIORITY_CLASS);
      ::SetThreadPriority(::GetCurrentThread(), THREAD_PRIORITY_IDLE);
   }
#else
      setpriority(PRIO_PROCESS, 0, 20);
#endif

   pSymbol=psymRuntime->LookupSymbol("_MAIN");
   if (pSymbol && pSymbol->GetSymbolType()==STRING_SYMBOL_TYPE)
      sFilename=pSymbol->GetStringValue();

   pSymbol=psymRuntime->LookupSymbol("_INFO");
   if(pSymbol)
   {
      char Buffer[512];
      getCpuDescription(Buffer, 1);
      PFPrintfLog("\nCPU Information (From Woltman v25 library code)\n%s\n", Buffer);
   }

   pSymbol=psymRuntime->LookupSymbol("_EXTRA_SQFREE");
   if(pSymbol && pSymbol->GetSymbolType()==INTEGER_SYMBOL_TYPE)
   {
      Integer iSQ=*(((PFIntegerSymbol*)pSymbol)->GetValue());
      g_ExtraSQFree=iSQ&0x7FFFFFFF;
   }

   pSymbol=psymRuntime->LookupSymbol("_LOGFILE");
   if (pSymbol && pSymbol->GetSymbolType()==STRING_SYMBOL_TYPE)
   {
      PFString s = pSymbol->GetStringValue();
      if (s == "")
         s = "pfgw.out";
      if (pOutputObj)
         pOutputObj->InitLogFile(LPCTSTR(s), (pTerseOutput != 0));
      else
      {
         PFOutput::EnableOneLineForceScreenOutput();
         PFPrintfStderr("error, pPutput is null\n");
      }
   }

   g_CompositeAthenticationLevel=0;   // always reset (allows multiple runs from WinPFGW)
   pSymbol=psymRuntime->LookupSymbol("_ATHENTICATION");
   if(pSymbol && pSymbol->GetSymbolType()==INTEGER_SYMBOL_TYPE)
   {
      Integer IAuth=*(((PFIntegerSymbol*)pSymbol)->GetValue());
      char *cp = IAuth.Itoa();
      g_CompositeAthenticationLevel = atoi(cp);
      delete[] cp;
      // Make sure we are "in range".
      if (g_CompositeAthenticationLevel < 0)
         g_CompositeAthenticationLevel = 0;
      if (g_CompositeAthenticationLevel > 5)
         g_CompositeAthenticationLevel = 5;
   }

   // Communicate these values to any SCRIPT so that it knows what the
   // "defaults" for factorizing are.
   g_MinStartingPrimeToFactor=g_MaxStoppingPrimeToFactor=0;
   pSymbol=psymRuntime->LookupSymbol("_PMIN");
   if (pSymbol && pSymbol->GetSymbolType()==INTEGER_SYMBOL_TYPE)
   {
      Integer I = *((PFIntegerSymbol*)pSymbol)->GetValue();
      uint64 n=1;
      I.m_mod(n<<62, &g_MinStartingPrimeToFactor);
   }
   pSymbol=psymRuntime->LookupSymbol("_PMAX");
   if (pSymbol && pSymbol->GetSymbolType()==INTEGER_SYMBOL_TYPE)
   {
      Integer I = *((PFIntegerSymbol*)pSymbol)->GetValue();
      uint64 n=1;
      I.m_mod(n<<62, &g_MaxStoppingPrimeToFactor);
   }

   pSymbol=psymRuntime->LookupSymbol("_FACTORIZE_STR");
   PFBoolean bFactor=(pSymbol==NULL)?PFBoolean::b_false:PFBoolean::b_true;
   *g_ModularSieveString = 0;

   if (pSymbol && pSymbol->GetSymbolType()==STRING_SYMBOL_TYPE)
   {
      bool bFactorize = true;
      PFString s = pSymbol->GetStringValue();
      char *cp = new char [strlen(LPCTSTR(s)) + 1];
      strcpy(cp, LPCTSTR(s));
      char *cp1 = strchr(cp, '{');
      if (cp1)
         *cp1 = 0;
      int iFactPercent=0;
      if (*cp >= '0' && *cp <= '9')
      {
         Integer FactPercent;
         FactPercent.atoI(cp);
         if (FactPercent > 0)
         {
            pSymbol=psymRuntime->LookupSymbol("_PMAX");
            if (pSymbol)
            {
               PFOutput::EnableOneLineForceScreenOutput();
               PFPrintfStderr("The optional <percent> when factoring is ignored with the -e switch.\n\n");
            }
            else
            {
               iFactPercent=FactPercent&0x0000FFFF;
               PFOutput::EnableOneLineForceScreenOutput();
               PFPrintfStderr("Factoring numbers to %d%% of normal.\n\n", iFactPercent);
            }
         }
         else if (FactPercent == 0 && *cp == '0')
         {
            // If 0% factoring, then do not even trial factor.
            PFOutput::EnableOneLineForceScreenOutput();
            if (!pTerseOutput)
               PFPrintfStderr("No factoring at all, not even trivial division\n");
            g_bTrialFactor=false;
            bFactor=PFBoolean::b_false;
            *g_ModularSieveString = 0;
            bFactorize = false;
         }
      }
      if (bFactorize)
      {
         psymRuntime->AddSymbol(new PFIntegerSymbol("_FACTORIZE",new Integer(iFactPercent)));

         // Was there a "modular" string?
         if (cp1)
         {
            *cp1 = '{';
            strncpy(g_ModularSieveString, cp1, sizeof(g_ModularSieveString)-1);
            g_ModularSieveString[sizeof(g_ModularSieveString)-1] = 0;
            PFPrintfLog ("Using modular factorization: %s\n", g_ModularSieveString);
            psymRuntime->AddSymbol(new PFStringSymbol("_MODFACTOR",g_ModularSieveString));
         }
      }
      delete[] cp;
   }

   pSymbol=psymRuntime->LookupSymbol("_CERTIFICATE");
   if (pSymbol && pSymbol->GetSymbolType()==STRING_SYMBOL_TYPE)
   {
      PFString s = pSymbol->GetStringValue();
      char Buf[100], Buf1[100];
      strncpy(Buf, s, 80);
      Buf[79] = 0;
      g_Cert_Type = 1;   // Default to "Brief (write checksum only)"
      g_Cert_Delete = 1;   // Default to "Delete composite certificates without factors"
      if (*Buf)
         sscanf(Buf, "%d:%d\n", &g_Cert_Type, &g_Cert_Delete);
      switch (g_Cert_Type)
      {
         case 0:
            strcpy(Buf, "None"); break;
         case 1:
            strcpy(Buf, "Brief (write checksum only)"); break;
         case 2:
            strcpy(Buf, "Verbose (write full decimal expansions)"); break;
         default:
            strcpy(Buf, "Invalid Cert_Type.  Defaulting to \"Brief (write checksum only)\"");
      }
      switch (g_Cert_Delete)
      {
         case 0:
            strcpy(Buf1, "Delete composite certificates"); break;
         case 1:
            strcpy(Buf1, "Delete composite certificates without factors"); break;
         case 2:
            strcpy(Buf1, "Never delete certificates"); break;
         default:
            strcpy(Buf1, "Invalid Cert_Delete.  Defaulting to \"Delete composite certificates without factors\"");
      }
      PFPrintfLog("Using certification level: \"%s\" and deletion of certificates \"%s\"\n", Buf, Buf1);
   }

   pSymbol=psymRuntime->LookupSymbol("_FFT_SIZE_ONLY");
   g_FFTSizeOnly=(pSymbol==NULL)?false:true;
   if (g_FFTSizeOnly) g_bVerbose = true;

   pSymbol=psymRuntime->LookupSymbol("_DEEPFACTOR");
   PFBoolean bDeep=(pSymbol==NULL)?PFBoolean::b_false:PFBoolean::b_true;

   pSymbol=psymRuntime->LookupSymbol("_ONLYFACTORS");
   PFBoolean bOnlyFactors=(pSymbol==NULL)?PFBoolean::b_false:PFBoolean::b_true;
   PFString sOnlyFactorType;
   if (pSymbol)
      sOnlyFactorType=pSymbol->GetStringValue();

   pSymbol = psymRuntime->LookupSymbol("_ROUNDOFFCHK");
   if (pSymbol)
      g_bErrorCheckAllTests = true;
   else
      g_bErrorCheckAllTests = false;

   pSymbol=psymRuntime->LookupSymbol("_BASE");
   if(pSymbol && pSymbol->GetSymbolType()==INTEGER_SYMBOL_TYPE)
   {
      Integer gBase=*(((PFIntegerSymbol*)pSymbol)->GetValue());
      int iNewBase=gBase&0x000000FF;
      if((gBase==iNewBase)&&(iNewBase>1)&&(iNewBase<256))
      {
         iBase=iNewBase;
      }
   }

   pSymbol=psymRuntime->LookupSymbol("_UPDATEINTERVAL");
   if(pSymbol && pSymbol->GetSymbolType()==INTEGER_SYMBOL_TYPE)
   {
      Integer gInterval=*(((PFIntegerSymbol*)pSymbol)->GetValue());
      int iNewIterationCnt=gInterval&0xFFFFFFFF;
      if(iNewIterationCnt >= 0)
         g_nIterationCnt = iNewIterationCnt;
   }

   pSymbol=psymRuntime->LookupSymbol("_FERMFACTOR");
   PFBoolean bGFNFactors=(pSymbol==NULL)?PFBoolean::b_false:PFBoolean::b_true;
   bool bOnlyGFFactors=false;
   if (pSymbol)
   {
      PFString sGFNFactorCmd;
      sGFNFactorCmd=pSymbol->GetStringValue();
      char s[250];
      strcpy(s, (LPCSTR)sGFNFactorCmd);
      // the g of gap= is already "burnt", so we look for the ap= which is all that should be left.
      if (!strncmp(s, "ap=", 3))
      {
         int gap;
         sscanf(s, "ap=%d", &gap);
         uint64 restart = 0;
         if (strchr(s, ','))
         {
            char *cp = strchr(s, ',');
            cp++;
            sscanf(cp, ULL_FORMAT, &restart);
         }
#if (0)
         printf ("gap=%d restart=%I64u\n", gap, restart);
         exit(0);
#endif
#if !defined (_MSC_VER)
         PFPrintfStderr ("ERROR, the Gapper function has not been ported outside of Visual C++ builds\n");
         exit(-1);
#else
         gw_gapper(sFilename, gap, restart);
#endif
         pfgw_main_cleanup();
         return 0;
      }

      Parse_GF_FactorCommandLine(LPCTSTR(sGFNFactorCmd), &bOnlyGFFactors);
   }

   g_QuickMode = false;
   pSymbol=psymRuntime->LookupSymbol("_QUIKEXPR");
   if (pSymbol)
   {
      // command line entered number i.e. the -q<expr>  command line param.  NOTE that no file will
      // be loaded or run. This argument eliminates any input filename.
      PFStringFile *fTmp = new PFStringFile;
      pFile = fTmp;
      fTmp->WriteToString(LPCTSTR(pSymbol->GetStringValue()));
      g_QuickMode = true;
   }

   pSymbol=psymRuntime->LookupSymbol("_BENCH");
   if(pSymbol)
   {
      bench(psymRuntime);
   }

   pSymbol=psymRuntime->LookupSymbol("_VECTORMODE");
   IPFSymbol *pSymbolJ=psymRuntime->LookupSymbol("_JBC");
   if(pSymbol)
   {
      vectorout(sFilename,psymRuntime);
   }
   else if(pSymbolJ && pSymbolJ->GetSymbolType()==STRING_SYMBOL_TYPE)
   {
      PFString sPhi=pSymbolJ->GetStringValue();

      if (sPhi == "test")
      {
         for (int i = 400; i < 501; i++)
         {
            char Buf[6];
            sprintf(Buf, "%d", i);
            sPhi = Buf;
            PhiCofactorExperiment(psymRuntime,sPhi,bFactor,bDeep,bOnlyFactors);
         }
         exit(0);
      }

      PhiCofactorExperiment(psymRuntime,sPhi,bFactor,bDeep,bOnlyFactors);
   }
   else
   {
      // Note that pFile can already be set.  It may be a PFStringFile, created within the parseCommandLine() function

      const char *cpError="Unknown Error Opening the file!";
      strncpy(g_szInputFileName, sFilename, sizeof(g_szInputFileName));
      if (!pFile)
         pFile = openInputFile(sFilename, g_pIni, &cpError);
      if (!pFile)
      {
         PFOutput::EnableOneLineForceScreenOutput();
         PFPrintfStderr("%s\n", cpError);
#if defined (_MSC_VER)
         // Allow messages to be posted and displayed in WinPFGW.
         Sleep(50);
#endif
         // Clean up memory.  NOTE WinPFGW can call this function MANY times, so if we don't
         // clean house, then we can get into serious trouble.  Without this cleanup, simply
         // selecting a bad file name, and repeatedly clicking on the "start" button in
         // WinPFGW will quickly leak tons of memory, FILES, and other things.
         pfgw_main_cleanup();
         return 3;
      }

      PFString sNumber;
      PFString sMessage;
      bool bMsgValid=false;
      bool bResultValid;
      bResultValid=false;
      Integer Result;

      CTimer ExtraOverhead_Timer;
      ExtraOverhead_Timer.Start();

      try
      {
      while (pFile->GetNextLine(sNumber, &Result, &bResultValid, psymRuntime) == PFSimpleFile::e_ok)
      {
         g_PRP_ReturnCode = 5;  // set to an "unknown" error code

         if (g_bExitNow)
            break;
         if(sNumber.IsEmpty()) continue;

         Integer *pResult;
         if (!bResultValid)
         {
            pResult=ex_evaluate(psymRuntime,LPCTSTR(sNumber));
            if(pResult==NULL)
            {
               PFPrintfLog("%s - Evaluator failed\n",LPCTSTR(sNumber));
               PFfflush(stdout);
               continue;
            }
         }
         else
            pResult = &Result;

         PFIntegerSymbol *pN=new PFIntegerSymbol("_N",pResult, bResultValid);
         psymRuntime->AddSymbol(pN);

         // format g_cpTestString
         if(sNumber.GetLength()<36)
         {
            strcpy(g_cpTestString, LPCTSTR(sNumber));
         }
         else
         {
            PFString sBegin=sNumber.Left(16);
            PFString sEnd=sNumber.Right(16);
            PFString sBrief=sBegin+"...."+sEnd;
            strcpy(g_cpTestString, LPCTSTR(sBrief));
         }

         // -t, test the current feature
         pSymbol=psymRuntime->LookupSymbol("_TESTMODE");
         g_bTestingMode = false;
         if (pSymbol)
         {
            g_bTestingMode = true;
            // decide which test to run
            PFString sTestName="pocklington";
            PFString sTestShortName="N-1";
            PFString sTestResult="PRP!";

            PFString sParameter=pSymbol->GetStringValue();
            char c=((LPCTSTR)sParameter)[0];

            // very TEMP fix for P4 failure in SSE2 code.
            unsigned oldCPU_FLAGS = CPU_FLAGS;
            if((c=='+')||(c=='p')||(c=='P'))
            {
               sTestName="morrison";
               sTestShortName="N+1";
               sTestResult="Lucas PRP!";
            }
            else if((c=='c')||(c=='C'))
            {
               sTestName="combined";
               sTestShortName="N-1/N+1";
               sTestResult="Fermat and Lucas PRP!";
            }

            PFPrintfLog("Primality testing %s [%s, Brillhart-Lehmer-Selfridge]\n",LPCTSTR(sNumber),LPCTSTR(sTestShortName));
            PFSymbolTable *pSubContext=new PFSymbolTable(psymRuntime);

            CTimer Timer;
            Timer.Start ();

            // SSE2 code FAILS with a GP for values under about 2^500, so for number of this size, we simply do not use SSE2.
            // Bug seen since 4/25/2003 version, never reported, and fixed in 10/27/2003 version
            //if (lg(*pResult) < 600)
            //   CPU_FLAGS &= ~CPU_SSE2;

            g_sTestMode = sTestShortName;
            g_sTestMode += ": ";
            // Force on error checking during testing mode NO MATTER WHAT.
            g_bErrorCheckAllTests = true;
            int iRetval=PFFunctionSymbol::CallSubroutine(sTestName,pSubContext);
            if (!g_bForceRoundOffChecking)
               g_bErrorCheckAllTests = false;
            g_sTestMode = "";

            CPU_FLAGS = oldCPU_FLAGS;

            if (g_bExitNow)
               break;

            double t;

            t = Timer.GetSecs ();

            *g_cpTestString = 0;

            PFString sResult="unknown";
            bool bIsPrimeOrPRP=false;
            switch(iRetval)
            {
            case PT_INCONCLUSIVE:
               {
               // This case can happen if the primality test failed to prove
               // primality.  An example would be a +1 test for a k*b^n+1
               // number.  Other examples would be the PRP cases above.
               FILE *f=fopen("pfgw.log","at");
               pFile->CurrentNumberIsPRPOrPrime(true, false, &bMsgValid, &sMessage);
               g_PRP_ReturnCode = 0;
               bIsPrimeOrPRP=true;
               if(f)
               {
                  fseek(f,0L,SEEK_END);
                  fprintf(f,"%s\n",LPCTSTR(sNumber));
                  if (bMsgValid)
                     fprintf (f, "%s\n", LPCTSTR(sMessage));
                  fclose(f);
               }
               sResult=sTestResult;
               break;
               }
            case PT_COMPOSITE:
               sResult="composite";
               pFile->CurrentNumberIsPRPOrPrime(false, false, &bMsgValid, &sMessage);
               g_PRP_ReturnCode = 1;
               if (bMsgValid)
               {
                  FILE *f=fopen("pfgw.log","at");
                  if (f)
                  {
                     fseek(f,0L,SEEK_END);
                     fprintf (f, "%s\n", LPCTSTR(sMessage));
                     fclose(f);
                  }
               }
               break;
            case PT_FACTOR:
               sResult="factored";
               // Would the "TRIVIAL_FACTORED" primes play a part here?
               pFile->CurrentNumberIsPRPOrPrime(false, false, &bMsgValid, &sMessage);
               g_PRP_ReturnCode = 1;
               if (bMsgValid)
               {
                  FILE *f=fopen("pfgw.log","at");
                  if(f)
                  {
                     fseek(f,0L,SEEK_END);
                     fprintf (f, "%s\n", LPCTSTR(sMessage));
                     fclose(f);
                  }
               }
               break;
            case PT_PRIME:
               {
               FILE *f=fopen("pfgw-prime.log","at");
               bIsPrimeOrPRP = true;
               pFile->CurrentNumberIsPRPOrPrime(false, true, &bMsgValid, &sMessage);
               g_PRP_ReturnCode = 0;
               if(f)
               {
                  fseek(f,0L,SEEK_END);
                  fprintf(f,"%s\n",LPCTSTR(sNumber));
                  if (bMsgValid)
                     fprintf (f, "%s\n", LPCTSTR(sMessage));
                  fclose(f);
               }
               sResult="prime!";
               break;
               }
            default:
               pFile->CurrentNumberIsPRPOrPrime(false, false, &bMsgValid, &sMessage);
               g_PRP_ReturnCode = 1;
               break;
            }

            double t2;
            t2 = ExtraOverhead_Timer.GetSecs ();
            ExtraOverhead_Timer.Start();

            PFPrintfLog("%s is %s (%0.4fs+%0.4fs)\n",LPCTSTR(sNumber),LPCTSTR(sResult),t,t2-t);

            if (bMsgValid)
               PFPrintfLog ("%s\n", LPCTSTR(sMessage));
            if (bIsPrimeOrPRP && bGFNFactors)
               ProcessGF_Factors(pResult, LPCSTR(sNumber));
            delete pSubContext;

            // WHY do this???  (This is done to "unlink" the Integer from the table, so that we can delete it (if need be))
            pN->SetValue(NULL);

            if (!bResultValid)
               delete pResult;
            pResult = 0;

            continue;         // just go straight to the next puppy
         }

         // The trivial test should identify real simple cases that screw it all up
         // like negatives, 0, 1, small
         PFBoolean bTrivial=PFBoolean::b_false;
         if (g_bTrialFactor)
         {
            psymRuntime->AddSymbol(new PFIntegerSymbol("_trivial_depth",new Integer(31))); // only trivial factor to 2^6
            PFFunctionSymbol::CallSubroutine("@trivial",psymRuntime);
            if (g_bExitNow)
               break;

            // the result of a trivial test is a factorization.
            pSymbol=psymRuntime->LookupSymbol("_TRIVIALNEG");
            if(pSymbol && (pSymbol->GetStringValue()=="1"))
            {
               PFPrintfLog("%s was negative, testing absolute value.\n",LPCTSTR(sNumber));
               PFfflush(stdout);
            }

            pSymbol=psymRuntime->LookupSymbol("_TRIVIALFACTOR");
            if (pSymbol && pSymbol->GetSymbolType()==FACTORIZATION_SYMBOL_TYPE)
            {
               PFFactorizationSymbol *pF=(PFFactorizationSymbol*)pSymbol;
               PFList<FactorNode> *pList=pF->AccessList();
               if(pList->GetSize()!=0)
               {
                  PFString sTrivial=pSymbol->GetStringValue();
                  // Ok, check for a prime (one factor, and not a power, ie 5 and not 5^3)
                  if (pList->GetSize()==1 && !strchr(LPCTSTR(sTrivial), '^'))
                  {
                     if (sTrivial == "1")
                     {
                        PFPrintfLog("%s is Unity (1)\n",LPCTSTR(sNumber));
                        pFile->CurrentNumberIsPRPOrPrime(false, false, &bMsgValid, &sMessage);
                        g_PRP_ReturnCode = 1;
                     }
                     else if (sTrivial == "0")
                     {
                        PFPrintfLog("%s is Zero (0)\n",LPCTSTR(sNumber));
                        pFile->CurrentNumberIsPRPOrPrime(false, false, &bMsgValid, &sMessage);
                        g_PRP_ReturnCode = 1;
                     }
                     else
                     {
                        // Only one factor, but is it a "power" or simply a single prime.
                        // stupid way to check for power, but it works.
                        FILE *f=fopen("pfgw-prime.log","at");
                        pFile->CurrentNumberIsPRPOrPrime(false, true, &bMsgValid, &sMessage);
                        g_PRP_ReturnCode = 0;
                        if (bMsgValid)
                           PFPrintfLog ("%s\n", LPCTSTR(sMessage));
                        if(f)
                        {
                           fseek(f,0L,SEEK_END);
                           fprintf(f,"%s\n",LPCTSTR(sNumber));
                           if (bMsgValid)
                              fprintf (f, "%s\n", LPCTSTR(sMessage));
                           fclose(f);
                        }
                        if (!bOnlyGFFactors)
                           PFPrintfLog("%s is trivially prime!: %s\n",LPCTSTR(sNumber),LPCTSTR(sTrivial));
                        if (bGFNFactors)
                            ProcessGF_Factors(pResult, LPCTSTR(sNumber));
                     }
                  }
                  else
                  {
                     pFile->CurrentNumberIsPRPOrPrime(false, false, &bMsgValid, &sMessage);
                     if (bMsgValid)
                     {
                        FILE *f=fopen("pfgw.log","at");
                        if (f)
                        {
                           fseek(f,0L,SEEK_END);
                           fprintf (f, "%s\n", LPCTSTR(sMessage));
                           fclose(f);
                        }
                     }
                     g_PRP_ReturnCode = 1;
                     PFPrintfLog("%s trivially factors as: %s\n",LPCTSTR(sNumber),LPCTSTR(sTrivial));
                  }
                  PFfflush(stdout);
                  bTrivial=PFBoolean::b_true;
               }
            }
         }
         else
         {
            // we have to check (and fix) by hand, negative, and 0, 1
            IPFSymbol *pSym=psymRuntime->LookupSymbol("_N");
            if(pSym && pSym->GetSymbolType()==INTEGER_SYMBOL_TYPE)
            {
               Integer *_pN=((PFIntegerSymbol*)pSym)->GetValue();
               if((*_pN)<0)
               {
                  (*_pN)*=-1;
                  PFPrintfLog("%s was negative, testing absolute value.\n",LPCTSTR(sNumber));
                  PFfflush(stdout);
               }
               if (*_pN == 0)
               {
                  PFPrintfLog("%s is Zero (0)\n",LPCTSTR(sNumber));
                  pFile->CurrentNumberIsPRPOrPrime(false, false, &bMsgValid, &sMessage);
                  g_PRP_ReturnCode = 1;
                  bTrivial=PFBoolean::b_true;
               }
               else if (*_pN == 1)
               {
                  PFPrintfLog("%s is Unity (1)\n",LPCTSTR(sNumber));
                  pFile->CurrentNumberIsPRPOrPrime(false, false, &bMsgValid, &sMessage);
                  g_PRP_ReturnCode = 1;
                  bTrivial=PFBoolean::b_true;
               }
            }
         }

         // try to factor the thing
         bool bPrimalityTest=true;

         if (bFactor && !bTrivial)
         {
            PFFactorizationSymbol *pffN;
            psymRuntime->AddSymbol(pffN=new PFFactorizationSymbol("_NFACTOR"));
            psymRuntime->AddSymbol(new PFStringSymbol("_SN","_NFACTOR"));
            g_sTestMode = "F: ";
            g_nIterationCnt *= 1000;
            if (g_ModularSieveString[0])
            {
               psymRuntime->AddSymbol(new PFStringSymbol("_USEMODFACTOR","_USEMODFACTOR"));
               psymRuntime->AddSymbol(new PFStringSymbol("_MODFACTOR",g_ModularSieveString));
            }
            PFFunctionSymbol::CallSubroutine("@factor",psymRuntime);
            g_nIterationCnt /= 1000;
            g_sTestMode = "";
            if (g_bExitNow)
               break;

            PFString sFactorization;
            sFactorization=pffN->GetStringValue();
            IPFSymbol *pQ=0;
            if (sFactorization!="1" && (pQ=psymRuntime->LookupSymbol("_Q")) != NULL)
            {
               Integer _Q=*((PFIntegerSymbol*)pQ)->GetValue();

               PFPrintfClearCurLine();
                 // Yes I know its a stupid way of finding if its a prime
               if (_Q==1 && !strchr(LPCTSTR(sFactorization), '^') && !strchr(LPCTSTR(sFactorization), '*'))
               {
                  // Have a prime number, maybe caused by -f switch being used.
                  FILE *f=fopen("pfgw-prime.log","at");
                  pFile->CurrentNumberIsPRPOrPrime(false, true, &bMsgValid, &sMessage);
                  g_PRP_ReturnCode = 0;
                  bTrivial=PFBoolean::b_true;
                  if (bMsgValid)
                     PFPrintfLog ("%s\n", LPCTSTR(sMessage));
                  if(f)
                  {
                     fseek(f,0L,SEEK_END);
                     fprintf(f,"%s\n",LPCTSTR(sNumber));
                     if (bMsgValid)
                        fprintf (f, "%s\n", LPCTSTR(sMessage));
                     fclose(f);
                  }
                  if (!bOnlyGFFactors)
                     PFPrintfLog("%s factors prime!: %s\n",LPCTSTR(sNumber),LPCTSTR(sFactorization));
                  if (bGFNFactors)
                     ProcessGF_Factors(pResult, LPCSTR(sNumber));
               }
               else
               {
                  PFPrintfLog("%s has factors: %s\n",LPCTSTR(sNumber),LPCTSTR(sFactorization));
                  if (!bDeep || _Q==1)
                     pFile->CurrentNumberIsPRPOrPrime(false, false, &bMsgValid, &sMessage);

                  g_PRP_ReturnCode = 1;
                  if (bMsgValid)
                  {
                     PFPrintfLog ("%s\n", LPCTSTR(sMessage));
                     FILE *f=fopen("pfgw.log","at");
                     if(f)
                     {
                        fseek(f,0L,SEEK_END);
                        fprintf (f, "%s\n", LPCTSTR(sMessage));
                        fclose(f);
                     }
                  }
               }
               PFfflush(stdout);

               // now the interesting bit. If deepfactor is on, test the cofactor,
               // unless it's like 1
               if(bDeep)
               {
                  IPFSymbol *_pQ=psymRuntime->LookupSymbol("_Q");
                  *pResult=*((PFIntegerSymbol*)_pQ)->GetValue();
                  // The '(' keeps the GFN format and the GF Factor format logic from recognizing the number.
                  sNumber=PFString("(") + sNumber + PFString(")/(") + sFactorization + PFString(")");

                  if(*pResult==1)
                  {
                     bPrimalityTest=false;
                  }
               }
               else
               {
                  bPrimalityTest=false;
               }
            }
         }

         if (bPrimalityTest && !bTrivial)
         {
            if (bOnlyFactors)
            {
               // just squirt sNumber and its value
               pFile->CurrentNumberIsPRPOrPrime(false, false, &bMsgValid, &sMessage);
               g_PRP_ReturnCode = 0;
               if (sOnlyFactorType=="d"||sOnlyFactorType=="D")
               {
                  PFString sDecimal=pN->GetStringValue();
                  PFPrintfLog("%s: %s\n",LPCTSTR(sNumber),LPCTSTR(sDecimal));
               }
               else
                  PFPrintfLog("%s has no small factor.\n",LPCTSTR(sNumber));
               PFfflush(stdout);
            }
            else if (bOnlyGFFactors)
            {
               if (!ProcessGF_Factors(pResult, LPCSTR(sNumber)))
                  PFPrintfLog ("Error %s is not of the correct form to be a GFermat Factor\n", LPCTSTR(sNumber));
            }
            else
            {
               CTimer Timer;
               Timer.Start ();

               int Retval;
               Retval = gwPRP(pResult, g_cpTestString,&g_u64ResidueVal);
               if (g_bExitNow)
                  break;

	       if (g_FFTSizeOnly)
		 continue;

	       double t;
               t = Timer.GetSecs ();

               if (Retval == 1)
               {
                  pFile->CurrentNumberIsPRPOrPrime(true, false, &bMsgValid, &sMessage);
                  g_PRP_ReturnCode = 0;
                  double t2;
                  t2 = ExtraOverhead_Timer.GetSecs ();
                  ExtraOverhead_Timer.Start();
                  PFPrintfLog("%s is %d-PRP! (%0.4fs+%0.4fs)\n",LPCTSTR(sNumber),iBaseUsed,t,t2-t);
                  if (bMsgValid)
                     PFPrintfLog ("%s\n", LPCTSTR(sMessage));
                  PFfflush(stdout);

                  FILE *f=fopen("pfgw.log","at");
                  if (f)
                  {
                     fseek(f,0L,SEEK_END);
                     fprintf(f,"%s\n",LPCTSTR(sNumber));
                     if (bMsgValid)
                        fprintf (f, "%s\n", LPCTSTR(sMessage));
                     fclose(f);
                  }
                  if (bGFNFactors)
                     ProcessGF_Factors(pResult, LPCSTR(sNumber));
               }
               else
               {
                  pFile->CurrentNumberIsPRPOrPrime(false, false, &bMsgValid, &sMessage);
                  g_PRP_ReturnCode = 1;
                  double t2;
                  t2 = ExtraOverhead_Timer.GetSecs ();
                  ExtraOverhead_Timer.Start();

                  if (!Retval)
                     PFPrintfLog("%s is composite: RES64: [%08X%08X] (%0.4fs+%0.4fs)\n",
                              LPCTSTR(sNumber), (uint32)(g_u64ResidueVal>>32), (uint32)(g_u64ResidueVal&0xFFFFFFFF), t, t2-t);
                  else
                     PFPrintfLog("%s ERROR DURING PROCESSING! (%0.4fs+%0.4fs)\n",LPCTSTR(sNumber),t, t2-t);

                  if (bMsgValid)
                  {
                     PFPrintfLog ("%s\n", LPCTSTR(sMessage));
                     FILE *f=fopen("pfgw.log","at");
                     if(f)
                     {
                        fseek(f,0L,SEEK_END);
                        fprintf (f, "%s\n", LPCTSTR(sMessage));
                        fclose(f);
                     }
                  }
                  PFfflush(stdout);
               }
            }
         }   // not factored
            // formerly the symbol pN was deleted, no longer do this so _N is accessible
      }   //end while
      }   //end try
      catch(...)
      {
         delete pFile;
         pFile = 0;
      }
      delete pFile;
      pFile=0;
   }   // arg count of 2

   }   // end try
#if !defined (_DEBUG)
   catch(...)
   {
      PFPrintfLog ("\rUnknown error in PFGW runtime\nPossibly a number too big for alloca version of GMP\n");
   }
#endif

   pfgw_main_cleanup();
   return g_PRP_ReturnCode;
}


static bool b_PFGW_Init=false;

void pfgw_main_init()
{
   if (b_PFGW_Init)
      return;
   b_PFGW_Init = true;

   getCpuInfo();
   crc_init();

   g_bExitNow = g_bExited = false;
   g_bGMPMode = false;

   g_bErrorCheckAllTests = false;

   PFIntegerSymbol::Startup();
   psymRuntime=new PFSymbolTable;

   // this section adds the evaluator functions to the symbol table. Note this
   // is moved to pfoo, so you can add functions without changing this code.
   PFFunctionSymbol::LoadAllFunctions(psymRuntime);
}

void pfgw_main_cleanup()
{
   if (!b_PFGW_Init)
      return;
   b_PFGW_Init = false;

   delete psymRuntime;         // will delete all symbols
   psymRuntime = 0;
   PFIntegerSymbol::Shutdown();
   Erat_Mod::FreeAllMemory();
   F_Factor::CleanupHelperFileObject();      // Clean up this "global" file handle.
   pOutputObj->CloseLogFile();
   g_bExited = true;
   CleanupGFs();
}
